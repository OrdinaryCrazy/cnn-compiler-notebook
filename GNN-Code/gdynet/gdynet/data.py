from __future__ import print_function, division

import numpy as np
from tensorflow import keras


class MDStackGenerator(keras.utils.Sequence):
    """
    The `MDDataGenerator` load data from a `NpzFile` generated by the
    preprocess function with `kdtree` mode. The file contain
    the following keyword variables.

    traj_coords: np.float32 arrays with shape (F, N, 3), stores the coordinates
        of each atom in each frame.
    lattices: np.float32 arrays with shape (F, 3, 3), stores the lattice
        matrix of the simulation box in each frame. In the lattice matrix,
        each row represents a lattice vector.
    atom_types: np.int32 arrays with shape (N,), stores the atomic number of
        each atom in the MD simulation.
    target_index: np.int32 arrays with shape (n,), stores the indexes of
        the target atoms. (`n <= N`)
    nbr_lists: np.int32 arrays with shape (F, N, n_nbrs), stores the indices
        of the neighboring atoms in the constructed graphs
    """
    def __init__(self, fnames, tau=1, n_classes=2,
                 batch_size=1024, random_seed=123, shuffle=True):
        self.fnames = fnames
        self.tau = tau
        self.n_classes = n_classes
        self.batch_size = batch_size
        self.random_seed = random_seed
        self.shuffle = shuffle
        try:
            self.load_data()
        except KeyError:
            raise KeyError('Data loader failed: choose `--mode direct` to load'
                           ' data preprocessed using `direct` backend.')
        self.indices = np.arange(self.n_traj * (self.n_frames - self.tau))
        self.random_seed = random_seed
        if self.shuffle:
            np.random.shuffle(self.indices)

    def load_data(self):
        traj_coords, atom_types, lattices, nbr_lists, target_index =\
            [], [], [], [], []
        for fname in self.fnames:
            with np.load(fname) as data:
                traj_coords.append(data['traj_coords'])
                atom_types.append(data['atom_types'])
                lattices.append(data['lattices'])
                nbr_lists.append(data['nbr_lists'])
                target_index.append(data['target_index'])
        all_types = np.stack(atom_types)
        all_target_index = np.stack(target_index)
        assert np.all(all_types == all_types[0]), 'Atoms should be the '\
            'same for each trajectory'
        assert np.all(all_target_index == all_target_index[0])
        self.atom_types = atom_types[0]
        self.target_index = all_target_index[0]
        self.traj_coords = np.stack(traj_coords, axis=0)
        self.nbr_lists = np.stack(nbr_lists, axis=0)
        self.lattices = np.stack(lattices, axis=0)
        self.n_traj, self.n_frames = self.traj_coords.shape[:2]

    def on_epoch_end(self):
        if self.shuffle:
            np.random.shuffle(self.indices)

    def __len__(self):
        return int(np.ceil(len(self.indices) / self.batch_size))

    def __getitem__(self, index):
        cur_indices = self.indices[index * self.batch_size:
                                   (index + 1) * self.batch_size]
        b_size = len(cur_indices)
        traj_indices, frame_indices = np.unravel_index(
            cur_indices, (self.n_traj, self.n_frames - self.tau))
        stacked_coords = np.stack(
            [self.traj_coords[traj_indices, frame_indices],
             self.traj_coords[traj_indices, frame_indices + self.tau]],
            axis=-1)
        stacked_lattices = np.stack(
            [self.lattices[traj_indices, frame_indices],
             self.lattices[traj_indices, frame_indices + self.tau]],
            axis=-1)
        stacked_nbr_lists = np.stack(
            [self.nbr_lists[traj_indices, frame_indices],
             self.nbr_lists[traj_indices, frame_indices + self.tau]],
            axis=-1)
        atom_types = np.tile(self.atom_types, (b_size, 1))
        target_index = np.tile(self.target_index, (b_size, 1))
        batch_Y = np.zeros([b_size, self.n_classes * 2], dtype='float32')
        return ([stacked_coords, stacked_lattices, stacked_nbr_lists,
                 atom_types, target_index], batch_Y)


class MDStackGenerator_direct(keras.utils.Sequence):
    """
    The `MDStackGenerator_direct` load data from a `NpzFile` generated by the
    preprocess function with `direct` mode. The file contain
    the following keyword variables.

    traj_coords: np.float32 arrays with shape (F, N, 3), stores the coordinates
        of each atom in each frame.
    atom_types: np.int32 arrays with shape (N,), stores the atomic number of
        each atom in the MD simulation.
    target_index: np.int32 arrays with shape (n,), stores the indexes of
        the target atoms. (`n <= N`)
    nbr_lists: np.int32 arrays with shape (F, N, n_nbrs), stores the indices
        of the neighboring atoms in the constructed graphs
    nbr_dists: np.float32 arrays with shape (F, N, n_nbrs), stores the
        distances between the center atom and the neighboring atoms in the
        constructed graphs
    """
    def __init__(self, fnames, tau=1, n_classes=2,
                 batch_size=1024, random_seed=123, shuffle=True):
        self.fnames = fnames
        self.tau = tau
        self.n_classes = n_classes
        self.batch_size = batch_size
        self.random_seed = random_seed
        self.shuffle = shuffle
        try:
            self.load_data()
        except KeyError:
            raise KeyError('Data loader failed: choose `--mode kdtree` to load'
                           ' data preprocessed using `kdtree` backend.')
        self.indices = np.arange(self.n_traj * (self.n_frames - self.tau))
        self.random_seed = random_seed
        if self.shuffle:
            np.random.shuffle(self.indices)

    def load_data(self):
        traj_coords, atom_types, nbr_lists, nbr_dists, target_index =\
            [], [], [], [], []
        for fname in self.fnames:
            with np.load(fname) as data:
                traj_coords.append(data['traj_coords'])
                atom_types.append(data['atom_types'])
                nbr_lists.append(data['nbr_lists'])
                nbr_dists.append(data['nbr_dists'])
                target_index.append(data['target_index'])
        all_types = np.stack(atom_types)
        all_target_index = np.stack(target_index)
        assert np.all(all_types == all_types[0]), 'Atoms should be the '\
            'same for each trajectory'
        assert np.all(all_target_index == all_target_index[0])
        self.atom_types = all_types[0]
        self.target_index = all_target_index[0]
        self.traj_coords = np.stack(traj_coords, axis=0)
        self.nbr_lists = np.stack(nbr_lists, axis=0)
        self.nbr_dists = np.stack(nbr_dists, axis=0)
        self.n_traj, self.n_frames = self.traj_coords.shape[:2]

    def on_epoch_end(self):
        if self.shuffle:
            np.random.shuffle(self.indices)

    def __len__(self):
        return int(np.ceil(len(self.indices) / self.batch_size))

    def __getitem__(self, index):
        cur_indices = self.indices[index * self.batch_size:
                                   (index + 1) * self.batch_size]
        b_size = len(cur_indices)
        traj_indices, frame_indices = np.unravel_index(
            cur_indices, (self.n_traj, self.n_frames - self.tau))
        nbr_list_1 = self.nbr_lists[traj_indices, frame_indices]
        nbr_list_2 = self.nbr_lists[traj_indices, frame_indices + self.tau]
        nbr_dist_1 = self.nbr_dists[traj_indices, frame_indices]
        nbr_dist_2 = self.nbr_dists[traj_indices, frame_indices + self.tau]
        atom_types = np.tile(self.atom_types, (b_size, 1))
        target_index = np.tile(self.target_index, (b_size, 1))
        batch_Y = np.zeros([b_size, self.n_classes * 2], dtype='float32')
        return ([atom_types, target_index, nbr_dist_1, nbr_list_1,
                 nbr_dist_2, nbr_list_2], batch_Y)


class MDStackGenerator_vannila(keras.utils.Sequence):
    """
    The `MDStackGenerator_vannila` load data from a `NpzFile` generated by the
    preprocess function with both `kdtree` and `direct` modes.

    traj_coords: np.float32 arrays with shape (F, N, 3), stores the coordinates
        of each atom in each frame.
    atom_types: np.int32 arrays with shape (N,), stores the atomic number of
        each atom in the MD simulation.
    target_index: np.int32 arrays with shape (n,), stores the indexes of
        the target atoms. (`n <= N`)
    """
    def __init__(self, fnames, tau=1, n_classes=2,
                 batch_size=1024, random_seed=123, shuffle=True):
        self.fnames = fnames
        self.tau = tau
        self.n_classes = n_classes
        self.batch_size = batch_size
        self.random_seed = random_seed
        self.shuffle = shuffle
        self.load_data()
        self.indices = np.arange(self.n_traj * (self.n_frames - self.tau))
        self.random_seed = random_seed
        if self.shuffle:
            np.random.shuffle(self.indices)

    def load_data(self):
        traj_coords, atom_types, target_index = [], [], []
        for fname in self.fnames:
            with np.load(fname) as data:
                traj_coords.append(data['traj_coords'])
                atom_types.append(data['atom_types'])
                target_index.append(data['target_index'])
        all_types = np.stack(atom_types)
        all_target_index = np.stack(target_index)
        assert np.all(all_types == all_types[0]), 'Atoms should be the '\
            'same for each trajectory'
        assert np.all(all_target_index == all_target_index[0])
        self.atom_types = all_types[0]
        self.target_index = all_target_index[0]
        self.traj_coords = np.stack(traj_coords, axis=0)
        self.n_traj, self.n_frames = self.traj_coords.shape[:2]

    def on_epoch_end(self):
        if self.shuffle:
            np.random.shuffle(self.indices)

    def __len__(self):
        return int(np.ceil(len(self.indices) / self.batch_size))

    def __getitem__(self, index):
        cur_indices = self.indices[index * self.batch_size:
                                   (index + 1) * self.batch_size]
        b_size = len(cur_indices)
        traj_indices, frame_indices = np.unravel_index(
            cur_indices, (self.n_traj, self.n_frames - self.tau))
        traj_coords_1 = self.traj_coords[traj_indices, frame_indices][
            :, self.target_index]
        traj_coords_2 = self.traj_coords[traj_indices,
                                         frame_indices + self.tau][
            :, self.target_index]
        batch_Y = np.zeros([b_size, self.n_classes * 2], dtype='float32')
        return ([traj_coords_1, traj_coords_2], batch_Y)
